<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>Symbolic Constants</title>
</head>

<body>
  <h1>Symbolic Constants</h1>

  <h2>Overview</h2>

  <p>It is often useful to define names which will be treated as
  constants.  <code class="API">twisted.python.constants</code> provides APIs
  for defining such symbolic constants with minimal overhead and some useful
  features beyond those afforded by the common Python idioms for this task.</p>

  <p>This document will explain how to use these APIs and what circumstances
  they might be helpful in.</p>

  <h2>Constant Names</h2>

  <p>Constants which have no value apart from their name and identity can be
  defined by subclassing <code class="API" base="twisted.python.constants">Names</code>.
  Consider this example, in which some HTTP request method constants are defined.</p>

  <pre class="python">
from twisted.python.constants import NamedConstant, Names
class METHOD(Names):
    """
    Constants representing various HTTP request methods.
    """
    GET = NamedConstant()
    PUT = NamedConstant()
    POST = NamedConstant()
    DELETE = NamedConstant()
  </pre>

  <p>Only direct subclasses of <code>Names</code> are supported (i.e., you
  cannot subclass <code>METHOD</code> to add new constants the collection).</p>

  <p>Given this definition, constants can be looked up by name using attribute
  access on the <code>METHOD</code> object:</p>

  <pre class="shell">
>>> METHOD.GET
&lt;METHOD=GET>
>>> METHOD.PUT
&lt;METHOD=PUT>
>>>
  </pre>

  <p>If it's necessary to look up constants based on user input of some sort, a
  safe way to do it is using <code>lookupByName</code>:</p>

  <pre class="shell">
>>> METHOD.lookupByName('GET')
&lt;METHOD=GET>
>>> METHOD.lookupByName('__doc__')
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "twisted/python/constants.py", line 145, in lookupByName
    raise ValueError(name)
ValueError: __doc__
>>>
  </pre>

  <p>As demonstrated, it is safe because any name not associated with a constant
  (even those special names initialized by Python itself) will result
  in <code>ValueError</code> being raised, not some other object not intended to
  be used the way the constants are used.</p>

  <p>The constants can also be enumerated using the <code>iterconstants</code>
  method.</p>

  <pre class="shell">
>>> list(METHOD.iterconstants())
[&lt;METHOD=GET>, &lt;METHOD=PUT>, &lt;METHOD=POST>, &lt;METHOD=DELETE>]
  </pre>

  <p>And constants can also be compared, either for equality or identity:</p>

  <pre class="shell">
>>> METHOD.GET is METHOD.GET
True
>>> METHOD.GET == METHOD.GET
True
>>> METHOD.GET is METHOD.PUT
False
>>> METHOD.GET == METHOD.PUT
False
>>>
  </pre>

  <p>Custom functionality can also be associated with constants defined this
  way.  A subclass of <code>Names</code> may define class methods to implement
  such functionality.  Consider this redefinition of <code>METHOD</code>:</p>

  <pre class="python">
from twisted.python.constants import NamedConstant, Names
class METHOD(Names):
    """
    Constants representing various HTTP request methods.
    """
    GET = NamedConstant()
    PUT = NamedConstant()
    POST = NamedConstant()
    DELETE = NamedConstant()

    @classmethod
    def isIdempotent(cls, method):
        """
        Return True if the given method is side-effect free, False otherwise.
        """
        return method is cls.GET
  </pre>

  <p>This functionality can be used as any class methods are used:</p>

  <pre class="shell">
>>> METHOD.isIdempotent(METHOD.GET)
True
>>> METHOD.isIdempotent(METHOD.POST)
False
>>>
  </pre>

</body>

</html>
