<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>twisted.cred: Authorization and Identities</title>
</head>

<body>
<h1>PB Walking Tour Part Two: twisted.cred</h1>

<a name="intro"><h2>Authentication, Identities, and Perspectives</h2></a>

<p>This next section is an exciting ride. Keep your arms and legs inside the
car at all times, you must be *this* tall to get on board, and we cannot be
responsible for any lost or stolen articles. Permanecen sentados, por
favor.</p>

<a name="motivation"><h2>Motivation</h2></a>

<p>So now that you've gotten through the <a href="pb-tour.html">PB Walking
Tour</a>, you've become a master at distributed objects and remote method
calls. What you've got so far is a really clean way to get objects and
references thrown around from one process to another. You've written a chat
server, and see the power of easy remote method calls.</p>

<p>But there were some problems. You had to trust the user when they said
their name was 'bob': no passwords or anything. If you wanted a direct-send
one-to-one message feature, you might have implemented it by handing a User
reference directly off to another User. (so they could invoke
<code>.remote_sendMessage()</code> on the receiving User): but that lets them do
anything else to that user too, things that should probably be restricted to
the "owner" user, like <code>.remote_joinGroup()</code> or
<code>.remote_quit()</code>.</p>

<p>And there were probably places where the easiest implementation was to
have the client send a message that included their own name as an argument.
Sending a message to the group could just be:</p>

<pre class="python">
class Group(pb.Referenceable):
  ...
  def remote_sendMessage(self, from_user, message):
    for user in self.users:
      user.callRemote("sendMessage", "[%s]: %s" % (from_user, message))
</pre>

<p>But obviously this lets users spoof each other: there's no reason that
Alice couldn't do:</p>

<pre class="python">
remotegroup.callRemote("sendMessage", "bob", "i like pork")
</pre>

<p>much to the horror of Bob's vegetarian friends.</p>

<p>(In general, learn to get suspicious if you see "groupName" or "userName"
in the argument list of a remotely-invokable method).</p>

<p>You could fix this by adding more classes (with fewer remotely-invokable
methods), and making sure that the reference you give to Alice won't let her
pretend to be anybody else. You'd probably give Alice her own object, with
her name buried inside:</p>

<pre class="python">
class User(pb.Referenceable):
  def __init__(self, name):
    self.name = name
  def remote_sendMessage(self, group, message):
    g = findgroup(group)
    for user in g.users:
      user.callRemote("sendMessage", "[%s]: %s" % (self.name, message)
</pre>

<p>This improves matters because, as long as Alice only has a reference to
<em>this</em> object and nobody else's, she can't cause a different
<code>self.name</code> to get used. Of course, you have to make sure that you
don't give her a reference to the wrong object. <a name="F1"><a href="#f1"
>[1]</a></a> </p>

<p>But now she could sneak into another group. So you might have to have an
object per-group-per-user:</p>


<pre class="python">
class UserGroup(pb.Referenceable):
  def __init__(self, group, user):
    self.group = group
    self.user = user
  def remote_sendMessage(self, message):
    name = self.user.name
    for user in self.group.users:
      user.callRemote("sendMessage", "[%s]: %s" % (name, message)
</pre>


<p>But that means more code, and more code is bad, especially when it's a
common problem (everybody designs with security in mind, right?
Right??).</p>


<p>So we have a security problem. We need a way to ask for and verify a
password, so we know that Bob is really Bob and not Alice wearing her "Hi,
my name is Bob" t-shirt. And it would make the code cleaner (i.e.: fewer
classes) if some methods could know reliably *who* is calling them. You
could add that layer of password checking to your application, but once
again the basement denizens at Twisted Matrix Laboratories have beaten you
to it.</p>


<a name="sample"><h2>A sample application</h2></a>

<p>As a framework for this chapter, we'll be referring to a hypothetical
game implemented by several programs using the Twisted framework. This game
will have multiple players, where users log in using their client programs,
and there is a server, and users can do some things but not others. <a
name="F2"><a href="#f2" >[2]</a></a></p>

<p>The players make moves in this game by invoking remote methods on objects
that live in the server. The clients can't really be relied upon to tell the
server who they are with each move they make: they might get it wrong, or
(horrors!) lie to mess up the other player.</p>

<p>Let's simplify it to a server-based game of Go (if that can be considered
simple). Go has two players, white and black, who take turns placing stones
of their own color at the intersections of a 19x19 grid. If we represent the
game and board as an object in the server called Game, then the players
might interact with it using something like this:</p>

<pre class="python">
class Game(pb.Referenceable):
  def remote_getBoard(self):
    return self.board # a dict, with the state of the board
  def remote_move(self, playerName, x, y):
    self.board[x,y] = playerName
</pre>

<p>"But Wait", you say, yes that method takes a playerName, which means they
could cheat and move for the other player. So instead, do this:</p>

<pre class="python">
class Game(pb.Referenceable):
  def remote_getBoard(self):
    return self.board # a dict, with the state of the board
  def move(self, playerName, x, y):
    self.board[x,y] = playerName
</pre>

<p>and move the responsibility (and capability) for calling Game.move() out
to a different class. That class is a pb.Perspective.</p>

<a name="perspectives"><h2>Perspectives</h2></a>

<p>pb.Perspective (and some related classes: Identity, Authorizer, and
Service) is a layer on top of the basic PB system that handles
username/password checking. The basic idea is that there is a separate
Perspective object (probably a subclass you've created) for each user <a
name="F3"><a href="#f3" >[3]</a></a>, and <em>only</em> the authorized user
gets a remote reference to that Perspective object. You can store whatever
permissions or capabilities the user possesses in that object, and then use
them when the user invokes a remote method. You give the user access to the
Perspective object instead of the objects that do the real work.</p>

<p>Your code can then look like this:</p>

<pre class="python">
class Game:
  def getBoard(self):
    return self.board # a dict, with the state of the board
  def move(self, playerName, x, y):
    self.board[x,y] = playerName

class PlayerPerspective(pb.Perspective):
  def __init__(self, playerName, game):
    self.playerName = playerName
    self.game = game
  def perspective_move(self, x, y):
    self.game.move(self.playerName, x, y)
  def perspective_getBoard(self):
    return self.game.getBoard()
</pre>

<p>The code on the server side creates the PlayerPerspective object, giving
it the right playerName and a reference to the Game object. The remote
player doesn't get a reference to the Game object, only their own
PlayerPerspective, so they don't have an opportunity to lie about their
name: it comes from the .playerName attribute, not an argument of their
remote method call.</p>

<p>Here is a brief example of using a Perspective. Most of the support code
is magic for now: we'll explain it later. <a name="F4"><a
href="#f4">[4]</a></a> </p>

<a href="listings/pb/pb5server.py" class="py-listing">pb5server.py</a>
<a href="listings/pb/pb5client.py" class="py-listing">pb5client.py</a>

<p>Note that once this example has done the method call, you'll have to
terminate both ends yourself. Also note that the Perspective's
<code>.attached()</code> and <code>.detached()</code> methods are run when the
client connects and disconnects. The base class implementations of these
methods just prints a message.</p>

<p>Ok, so that wasn't really very exciting. It doesn't accomplish much more
than the first PB example, and used a lot more code to do it. Let's try it
again with two users this time, each with their own Perspective. We also
override <code>.attached()</code> and <code>.detached()</code> <a name="F5"><a
href="#f5">[5]</a></a>, just to see how they are called.</p>


<a href="listings/pb/pb6server.py" class="py-listing">pb6server.py</a>
<a href="listings/pb/pb6client1.py" class="py-listing">pb6client1.py</a>
<a href="listings/pb/pb6client2.py" class="py-listing">pb6client2.py</a>

<p>While pb6server.py is running, try starting pb6client1, then pb6client2.
Compare the argument passed by the <code>.callRemote()</code> in each client.
You can see how each client logs into a different Perspective.</p>


<a name="overview"><h2>Class Overview</h2></a>

<p>Now that we've seen some of the motivation behind the Perspective class,
let's start to de-mystify some of the parts labeled "magic" in pb6server.py.
Here are the major classes involved:</p>

<ul>
  <li><code class="API" base="twisted.internet.app">Application</code>:
  <code>twisted/internet/app.py</code></li>
  <li><code class="API" base="twisted.cred.service">Service</code>:
  <code>twisted/cred/service.py</code></li>
  <li><code class="API" base="twisted.cred.authorizer">Authorizer</code>:
  <code>twisted/cred/authorizer.py</code></li>
  <li><code class="API" base="twisted.cred.identity">Identity</code>:
  <code>twisted/cred/identity.py</code></li>
  <li><code class="API" base="twisted.cred.pb">Perspective</code>:
  <code>twisted/cred/pb.py</code></li>
</ul>

<p>You've already seen <code>Application</code>. It holds the program-wide
settings, like which uid/gid it should run under, and contains a list of
ports that it should listen on (with a Factory for each one to create
Protocol objects). When used for PB, we put a pb.BrokerFactory on the port.
The <code>Application</code> also holds a list of Services.</p>

<p>A <code>Service</code> is, well, a service. A web server would be a
<code>Service</code>, as would a chat server, or any other kind of server
you might choose to run. What's the difference between a
<code>Service</code> and an <code>Application</code>? You can have multiple
<code>Service</code>s in a single <code>Application</code>: perhaps both a
web-based chat service and an IM server in the same program, that let you
exchange messages between the two. Or your program might provide different
kinds of interfaces to different classes of users: administrators could get
one <code>Service</code>, while mere end-users get a less-powerful
<code>Service</code>. <a name="F6"><a href="#f6">[6]</a></a> </p>

<p>The <code>Service</code> is reponsible for providing
<code>Perspective</code> objects. More on that later.</p>

<p>The <code>Authorizer</code> is a class that provides
<code>Identity</code> objects. The abstract base class is
<code>twisted.cred.authorizer.Authorizer</code>, and for simple purposes you can
just use <code class="API"
base="twisted.cred.authorizer">DefaultAuthorizer</code>, which is a subclass
that stores pre-generated Identities in a simple dict (indexed by username).
The <code>Authorizer</code>'s purpose in life is to implement the
<code>.getIdentityRequest()</code> method, which takes a user name and
(eventually) returns the corresponding <code>Identity</code> object.</p>

<p>Each <code>Identity</code> object represents a single user, with a
username and a password of some sort. Its job is to talk to the
as-yet-anonymous remote user and verify that they really are who they claim
to be. The default <code class="API">twisted.cred.authorizer.Identity</code>
class implements MD5-hashed challenge-response password authorization, much
like the HTTP MD5-Authentication method: the server sends a random challenge
string, the client concatenates a hash of their password with the challenge
string, and sends back a hash of the result. At this point the client is
said to be "authorized" for access to that <code>Identity</code>, and they
are given a remote reference to the <code>Identity</code> (actually a
wrapper around it), giving them all the privileges of that
<code>Identity</code>.</p>

<p>Those privileges are limited to requesting <code>Perspective</code>s. The
<code>Identity</code> object also has a "keyring", which is a list of
(serviceName, perspectiveName) pairs that the corresponding authorized user
is allowed to access. Once the user has been authenticated, the
<code>Identity</code>'s job is to implement
<code>.requestPerspectiveForKey()</code>, which it does by verifying the "key"
exists on the keyring, then asking the matching <code>Service</code> to do
<code>.getPerspectiveForIdentity()</code>.</p>

<p>Finally, the <code>Perspective</code> is the subclass of pb.Perspective
that implements whatever <code>perspective_*</code> methods you wish to expose to an
authenticated remote user. It also implements <code>.attached()</code> and
<code>.detached()</code>, which are run when the user connects (actually when
they finish the authentication sequence) or disconnects. Each
<code>Perspective</code> has a name, which is scoped to the
<code>Service</code> which owns the <code>Perspective</code>.

</p>


<a name="responsibilities"><h2>Class Responsibilities</h2></a>

<p>Now that we've gone over the classes and objects involved, let's look at
the specific responsibilities of each. Most of these classes are on the hook
to implement just one or two particular methods, and the rest of the class
is just support code (or the main method has been broken up for ease of
subclassing). This section indicates what those main methods are and when
they get called.</p>


<a name="responsibilities/authorizer"><h3>Authorizer</h3></a>

<p>The <code>Authorizer</code> has to provide <code>Identity</code> objects
(requested by name) by implementing <code>.getIdentityRequest()</code>. The
<code class="API" base="twisted.cred.authorizer">DefaultAuthorizer</code>
class just looks up the name in a dict called <code
class="python">self.identities</code>, so when you use it, you have to make
the Identities ahead of time (using <code class="python">i =
auth.createIdentity()</code>) and store them in that dict (by handing them
to <code class="python">auth.addIdentity(i)</code>).</p>

<p>However, you can make a subclass of <code>Authorizer</code> with a
<code>.getIdentityRequest</code> method that behaves differently: your version
could look in <code>/etc/passwd</code>, or do an SQL database lookup<a
name="F7"><a href="#f7">[7]</a></a>, or create new Identities for anyone
that asks (with a really secret password like '1234' that the user will
probably never change, even if you ask them to). The Identities could be
created by your server at startup time and stored in a dict, or they could
be pickled and stored in a file until needed (in which case
<code>.getIdentityRequest()</code> would use the username to find a file,
unpickle the contents, and return the resulting <code>Identity</code>
object), or created brand-new based upon whatever data you want. Any
function that returns a Deferred (that will eventually get called back with
the <code>Identity</code> object) can be used here.<a
name="F8"><a href="#f8">[8]</a></a></p>


<a name="responsibilities/identity"><h3>Identity</h3></a>

<p>The <code>Identity</code> object thus returned has two responsibilities.
The first is to authenticate the user, because so far they are unverified:
they have claimed to be somebody (by giving a username to the Authorizer),
but have not yet proved that claim. It does this by implementing
<code>.verifyPassword</code>, which is called by IdentityWrapper (described
later) as part of the challenge-response sequence. If the password is valid,
<code>.verifyPassword</code> should return a Deferred and run its callback. If
the password is wrong, the Deferred should have the error-back run
instead.</p>

<p>The second responsibility is to provide <code>Perspective</code> objects
to users who are allowed to access them. The authenticated user gives a
service name and a perspective name, and
<code>.requestPerspectiveForKey()</code> is invoked to retrieve the given
<code>Perspective</code>. The <code>Identity</code> is the one who decides
which services/perspectives the user is allowed to access. Unless you
override it in a subclass, the default implementation uses a simple dict
called <code>.keyring</code>, which has keys that are (servicename,
perspectivename) pairs. If the requested name pair is in the keyring, access
is allowed, and the <code>Identity</code> will proceed to ask the
<code>Service</code> to give back the specified <code>Perspective</code> to the
user. <code>.requestPerspectiveForKey()</code> is required to return a Deferred,
which will eventually be called back with a <code>Perspective</code> object,
or error-backed with a <code>Failure</code> object if they were not allowed
access.</p>


XXX: explain perspective names being scoped to services better


<p>You could subclass <code>Identity</code> to change the behavior of either
of these, but chances are you won't bother. The only reason to change
<code>.verifyPassword()</code> would be to replace it with some kind of
public-key verification scheme, but that would require changes to <code
class="API" base="twisted.spread">pb.IdentityWrapper</code> too, as well as
significant changes on the client side. Any changes you might want to make
to <code>.requestPerspectiveForKey()</code> are probably more appropriate to put
in the Service's <code>.getPerspectiveForIdentity</code> method instead. The
Identity simply passes all requests for Perspectives off to the Service.</p>

<p>The default <code>Identity</code> objects are created with a username and
password, and a "keyring" of valid service/perspective name pairs. They are
children of an <code>Authorizer</code> object. The best way to create them
is to have the <code>Authorizer</code> do it for you, then fill in the
details, by doing the following:</p>

<pre class="python">
i = auth.createIdentity("username")
i.setPassword("password")
i.addKeyByString("service", "perspective")
auth.addIdentity(i)
</pre>


<a name="responsibilities/service"><h3>Service</h3></a>

<p>The <code class="API" base="twisted.cred.service">Service</code> object's
job is to provide <code>Perspective</code> instances, by implementing
<code>.getPerspectiveForIdentity()</code>. This function takes a Perspective
name, and is expected to return a Deferred which will (eventually) be called
back with an instance of <code>Perspective</code> (or a subclass).</p>

<p> The default implementation (in <code
class="API">twisted.spread.pb.Service</code>) retrieves static pre-generated
<code>Perspective</code>s from a dict (indexed by perspective name), much
like DefaultAuthorizer does with Identities. And like
<code>Authorizer</code>, it is very useful to subclass <code class="API"
base="twisted.spread">pb.Service</code> to change the way
<code>.getPerspectiveForIdentity()</code> works: to create
<code>Perspective</code>s out of persistent data or database lookups, to set
extra attributes in the <code>Perspective</code>, etc.</p>

<p>When using the default implementation, you have to create the
<code>Perspective</code>s at startup time. Each <code>Service</code> object
has an attribute named <code>.perspectiveClass</code>, which helps it to create
the <code>Perspective</code> objects for you. You do this by running <code
class="python">p = svc.createPerspective("perspective_name")</code>.</p>

<p>You should use <code>.createPerspective()</code> rather than running the
constructor of your Perspective-subclass by hand, because the Perspective
object needs a pointer to its parent <code>Service</code> object, and the
<code>Service</code> needs to have a list of all the <code>Perspective</code>s that
it contains.</p>


<a name="smallexample"><h2>How that example worked</h2></a>

<p>Ok, so that's what everything is supposed to do. Now you can walk through
the previous example and see what was going on: we created a subclass called
<code>MyPerspective</code>, made a <code>DefaultAuthorizer</code> and added
it to the <code>Application</code>, created a <code>Service</code> and told
it to make <code>MyPerspective</code>s, used <code>.createPerspective()</code>
to build a few, for each one we made an <code>Identity</code> (with a
username and password), and allowed that <code>Identity</code> to access a
single <code>MyPerspective</code> by adding it to the keyring. We added the
<code>Identity</code> objects to the <code>Authorizer</code>, and then glued
the authorizer to the <code>pb.BrokerFactory</code>.</p>

<p>How did that last bit of magic glue work? I won't tell you here<a
name="F9"><a href="#f9">[9]</a></a>, because it isn't very useful to
override it, but you effectively hang an <code>Authorizer</code> off of a
TCP port. The combination of the object and methods exported by the <code
class="API" base="twisted.spread">pb.AuthRoot</code> object works together
with the code inside the <code>pb.connect()</code> function to implement both
sides of the challenge-response sequence. When you (as the client) use
<code>pb.connect()</code> to get to a given host/port, you end up talking to a
single <code>Authorizer</code>. The username/password you give get matched
against the <code>Identities</code> provided by that authorizer, and then the
servicename/perspectivename you give are matched against the ones authorized
by the <code>Identity</code> (in its <code>.keyring</code> attribute). You
eventually get back a remote reference to a <code>Perspective</code>
provided by the <code>Service</code> that you named.</p>


<a name="walkthrough"><h2>Code Walkthrough: pb.connect()</h2></a>

<p>So, now that you've seen the complete sequence, it's time for a code
walkthrough. This will give you a chance to see the places where you might
write subclasses to implement different behaviors. We will look at what
happens when <code>pb6client1.py</code> meets <code>pb6server.py</code>. We tune in
just as the client has run the <code class="python">pb.connect()</code>
call.</p>

<p>The client-side code can be summarized by the following sequence of
function calls, all implemented in twisted/spread/pb.py . <code
class="python">pb.connect()</code> calls <code
class="python">getObjectAt()</code> directly, after that each step is
executed as a callback when the previous step completes.</p>

<pre>
 getObjectAt(host,port,timeout)
 logIn(): authServRef.callRemote('username', username)
 _cbLogInRespond(): challenger.callRemote('respond', f[challenge,password])
 _cbLogInResponded(): identity.callRemote('attach', servicename,
                                          perspectivename, client)
 usercallback(perspective)
</pre>

<p>The client does <code class="python">getObjectAt()</code> to connect to
the given host and port, and retrieve the object named "root". On the server
side, the <code>BrokerFactory</code> accepts the connection, asks the <code
class="API" base="twisted.spread">pb.AuthRoot</code> object for its <code
class="python">.rootObject()</code>, getting an <code class="API"
base="twisted.spread.pb">AuthServ</code> object (containing both the
authorizer and the <code class="API" base="twisted.spread.pb">Broker</code>
protocol object). It gives a remote reference to that <code>AuthServ</code> out
to the client.</p>

<p>Now the client invokes the '<code>.remote_username</code>' method on that
<code>AuthServ</code>. The <code>AuthServ</code> asks the <code>Authorizer</code> to
<code class="python">.getIdentityRequest()</code>: this retrieves (or
creates) the <code>Identity</code>. When that finishes, it asks the
<code>Identity</code> to create a random challenge (usually just a random
string). The client is given back both the challenge and a reference to a
new <code class="API" base="twisted.spread.pb">AuthChallenger</code> object
which will only accept a response that matches that exact challenge.</p>

<p>The client does its part of the MD5 challenge-response protocol and sends
the response to the <code>AuthChallenger</code>'s
<code>.remote_response()</code> method. The <code>AuthChallenger</code> verifies
the response: if it is valid then it gives back a reference to an <code
class="API" base="twisted.spread.pb">IdentityWrapper</code>, which contains
an internal reference to the <code>Identity</code> that we now know matches
the user at the other end of the connection.</p>

<p>The client then invokes the '<code>.remote_attach</code>' method on that
<code>IdentityWrapper</code>, passing in a serviceName, perspectiveName, and
remoteRef. The wrapper asks the <code>Identity</code> to get a perspective
using <code>identity.requestPerspectiveForKey</code>, which does the "is
this user allowed to get this service/perspective" check by looking at the
tuples on its <code>.keyring</code>, and if that is allowed then it gets the
<code class="API" base="twisted.spread.pb">Service</code> (by giving
serviceName to the authorizer), then asks the <code>Service</code> to
provide the perspective (with <code>svc.getPerspectiveForIdentity</code>).
The default <code class="API" base="twisted.cred.service">Service</code>
will ignore the identity object and just look for <code>Perspective</code>s
by perspectiveName. The <code>Service</code> looks up or creates the
<code>Perspective</code> and returns it. The <code>.remote_attach</code> method
runs the Perspective's <code>.attached</code> method (although there are some
intermediate steps, in <code>IdentityWrapper._attached</code>, to make sure
<code>.detached</code> will eventually be run, and the Perspective's
<code>.brokerAttached</code> method is executed to give it a chance to return
some other Perspective instead). Finally a remote reference to the <code
class="API" base="twisted.spread.pb">Perspective</code> is returned to the
client.</p>

<p>The client gives the <code>Perspective</code> reference to the callback
that was attached to the <code>Deferred</code> that
<code>pb.connect()</code> returned, which brings us back up to the code
visible in <code>pb6client1.py</code>.</p>



<a name="bigexample"><h2>A Larger Example</h2></a>

<p>Now it's time to look more closely at the Go server described before.</p>

<p>To simplify the example, we will build a server that handles just a
single game. There are a variety of players who can participate in the game,
named Alice, Bob, etc (the usual suspects). Two of them log in, choose
sides, and begin to make moves.</p>

<p> We assume that the rules of the game are encapsulated into a
<code>GoGame</code> object, so we can focus on the code that handles the remote
players.</p>

<p>XXX: finish this section</p>


<p>That's the end of the tour. If you have any questions, the folks at the
welcome office will be more than happy to help. Don't forget to stop at the
gift store on your way out, and have a really nice day. Buh-bye now!</p>


<h2>Footnotes</h2>



<a  name="f1"><a href="#F1">[1]</a></a>

<p>Footnote: third party references (there aren't any)</p>

<p>Note that the reference that the server gives to a client is only useable
by that one client: if they try to hand it off to a third party, they'll get
an exception (XXX: which?). This helps somewhat: only the client you gave
the reference to can cause any damage with it. Of course, the client might
be a brainless zombie, simply doing anything some third party wants. When
it's not proxying <code>callRemote</code> invocations, it's probably terrorizing
the living and searching out human brains for sustenance. In short, if you
don't trust them, don't give them that reference.</p>

<p>Also note that the design of the serialization mechanism (implemented in
<code class="API">twisted.spread.jelly</code>: pb, jelly, spread.. get it?
Also look for "banana" and "marmalade". What other networking framework can
claim API names based on sandwich ingredients?) makes it impossible for the
client to obtain a reference that they weren't explicitly given. References
passed over the wire are given id numbers and recorded in a per-connection
dictionary. If you didn't give them the reference, the id number won't be in
the dict, and no amount of id guessing by a malicious client will give them
anything else. The dict goes away when the connection is dropped, limiting
further the scope of those references.</p>

<p>Of course, everything you've ever given them over that connection can
come back to you. If expect the client to invoke your method with some
object A that you sent to them earlier, and instead they send you object B
(that you also sent to them earlier), and you don't check it somehow, then
you've just opened up a security hole. A better design is to keep such
objects in a dictionary on the server side, and have the client send you an
index string instead. Doing it that way makes it obvious that they can send
you anything they want, and improves the chances that you'll remember to
implement the right checks.</p>


<a  name="f2"><a href="#F2">[2]</a></a>

<p>There actually exists such a thing. It's called twisted.reality, and was
the whole reason Twisted was created. I haven't played it yet: I'm too
afraid </p>

<a  name="f3"><a href="#F3">[3]</a></a>

<p>actually there is a perspective per user*service, but we'll get into that
later</p>

<a  name="f4"><a href="#F4">[4]</a></a>

<p>This example has more support code than you'd actually need. If you only
have one Service, then there's probably a one-to-one relationship between
your Identities and your Perspectives. If that's the case, you can use a
utility method called Perspective.makeIdentity() instead of creating the
perspectives and identities in separate steps. This is shorter, but hides
some of the details that are useful here to explain what's going on. Again,
this will make more sense later. </p>

<a  name="f5"><a href="#F5">[5]</a></a>

<p>The Perspective object is usually expected to outlast the user's
connection to it: it is nominally created some time before the user
connects, and survives after they disconnect. <code>.attached()</code> and
<code>.detached()</code> are invoked to let the Perspective know when the user
has connected and disconnected.</p>

<p> When the client runs <code>pb.connect</code> to establish the connection,
they can provide it with an optional '<code>client</code>' argument (which must
be a <code>pb.Referenceable</code> object). If they do, then a reference to that
object will be handed to the server-side Perspective's <code>.attached</code>
method, in the '<code>clientref</code>' argument. </p>

<p> The server-side Perspective can use it to invoke remote methods on
something in the client, so that the client doesn't always have to drive the
interaction. In a chat server, the client object would be the one to which
"display text" messages were sent. In a game, this would provide a way to
tell the clients that someone has made a move, so they can update their game
boards. To actually use it, you'd probably want to subclass Perspective and
change the .attached method to stash the clientref somewhere, because the
default implementation just drops it.</p>

<p><code>.attached()</code> also receives a reference to the <code>Identity</code>
object that represents the user. (The user has proved, by using a password
of some sort, that they are that <code>Identity</code>, and then they can access
any service/perspective on the Identity's keyring). The method can use that
reference to extract more information about the user.</p>

<p>In addition, <code>.attached()</code> has the opportunity to return a
different Perspective, if it so chooses. You could have all users initially
access the same Perspective, but then as they connect (and
<code>.attached()</code> gets called), give them unique Perspectives based upon
their individual Identities. The client will get a reference to whatever
<code>.attached()</code> returns, so the default case is to 'return self'.</p>

<p>Finally, when the client goes away (i.e., the network connection has been
closed), <code>.detached()</code> will be called. The Perspective can use this
to mark the user as having gone away: this may mean that outgoing messages
should be queued in the Perspective until they reconnect, or callers should
be given an error message because they messages cannot be delivered, etc. It
can also be used to terminate or suspend any sessions the user was
participating in. <code>detached</code> is called with the same 'clientref' and
Identity objects that were given to the original 'attached' call. It will be
invoked on the Perspective object that was returned by <code>.attached()</code>.
</p>

<a  name="f6"><a href="#F6">[6]</a></a>

<p>Note that the <code>Service</code> is a server of some sort, but that
doesn't mean there's a one-to-one relationship between the
<code>Service</code> and the TCP port that's being listened to. In theory,
several different <code>Service</code>s can hang off the same TCP port. Look
at the MultiService class for details.</p>

<a  name="f7"><a href="#F7">[7]</a></a>

<p>See twisted.enterprise.dbcred for a module that does exactly that.</p>

<a  name="f8"><a href="#F8">[8]</a></a>

<p>For static Identities that are available right away, the Deferred's
callback() method is called right away. This is why the interface of
<code>.getIdentityRequest()</code> specifies that its Deferred is returned
unarmed, so that the caller has a chance to actually add a callback to it
before the callback gets run. (XXX: check, I think armed/unarmed is an
outdated concept)</p>

<a  name="f9"><a href="#F9">[9]</a></a>

<p>but I will tell you here:</p>

<pre class="python">
app.listenTCP(8800, pb.BrokerFactory(pb.AuthRoot(auth)))
</pre>

<p><code class="python">pb.AuthRoot()</code> provides objects that are
subclassed from <code class="API" base="twisted.spread">pb.Root</code>, so
as we saw in the first example, they can be served up by <code
class="python">pb.BrokerFactory()</code>. <code>AuthRoot</code> happens to
use the <code>.rootObject</code> hook described earlier to serve up an <code
class="API" base="twisted.spread.pb">AuthServ</code> object, which wraps the
<code class="API" base="twisted.cred.authorizer">Authorizer</code> and
offers a method called <code>.remote_username</code>, which is called by the
client to declare which <code>Identity</code> it claims to be. That method
starts the challenge-response sequence.</p>

</body> </html>
